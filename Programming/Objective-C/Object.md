
1. Class 와 Instance
    - 객체지향: 객체 안에 속성과 메서드 형태로 함수를 구현하고 프로그램을 구성하는 객체들끼리 메시지를 주고 받아 협력 하는 형태로 동작.
    - 클래스: 문제 해결을 위해 추상화해서 만드는 코드
    - 객체: 프로그램을 실행하는 시점에 메모리에 구체화된 실체(Instance)
    1. 자연에 실존하는 객체를 그에 대응하는 형체가 없는 개념과 언어로 추상화시켜 생각 하는 방식.
    2. 객체 중심 프로그래밍
        - 개념(같은 언어를 사용하는 사람들끼리 생각하는 방식에 대한 원칙(단어의 의미, 문법)) 과 구현(실제 상황에 따라 달라지는 표현 방식)
        - 클래스 코드 --일반화, 추상화--> 객체 인스턴스
        - 클래스 코드 <--구체화, 개별화-- 객체 인스턴스
        - 클래스 단위로 역할과 책임을 나누고, 코드로 표현하기위한 설계에 필요한 다섯가지 원칙: SOLID
            - 클래스 코드를 작성할 때 명확하고 깔끔한 책임 구조와 높은응집혁, 낮은 의존성, 변화에 대한 유용성 등
    3. Objective-C 객체
        - 변수의 포인터가 가리키는 객체 인스턴스는 클래스의 코드를 공유하고(객체 인스턴스의 포인터가 클래스를 가리킴), 다른 인스턴스와는 구분되는 고유한 데이터를 포함.
        - 객체 인스턴스는 isa 포인터로 자신을 추상화한 클래스를 가리킨다.
        - 클래스로 작성한 코드는 모든 객체가 공유하고, 클래스 명세를 기준으로 만들어진 각각의 객체 인스턴스가 클래스 코드를 재사용.
    4. 스위프트 네이티브 객체
        - 스위프트 네이티브 객체는 다른 객체를 지정하지 않아도, 생성을 위해 allocating_init()과 init() 함수를 생성하고, 소멸을 위해 deallocating_deinit()과 deinit() 함수를 생성.
        - Objective-C 객체는 메모리 할당을 위한 +alloc 메서드와 초기 값을 설정하는 -init 메서드가 나눠져 있지만, 스위프트 객체는 allocating_init() 함수에서 alloc_ref() 함수를 통해 메모리를 할당하고 곧바로 init() 메서드를 호출해서 내부 변수를 초기화함.
        - deallocation_deinit() 메서드는 숨겨진 첫번째 %0 파라미터인 self 객체 레퍼런스를 class.deinit() 메서드에 넘겨서 힙에 만들어진 레퍼런스 변수를 소멸하고, dealloc_ref() 함수를 통해 자기 스스로를 메모리에서 해제
        - SIL(Swift Intermediate Language): 스위프트 컴파일러 swiftc가 스위프트 언어로 작성된 코드 파일을 읽어 스위프트 중간언어(SIL) 로 만들고 LLVM IR로 변환 후, LLVM IR 최적화기를 거쳐서 최종적으로 타깃 머신에 맞는 기계 코드(MC)가 생성된다.
        - getter / setter
            - let 으로 선언된 경우, 변경이 불가능 하기에 setter 함수는 없고, getter 함수에서 ref_element_addr() 명령으로 객체 변수의 참조 주소를 가져오고 load() 명령으로 실제 메모리에서 값을 복사.
            - swiftc는 중간언어를 세밀하게 나눠서 스위프트 런타임 API 함수를 호출하거나 더 낮은 수준의 LLVM IR로 바꾸기도 한다.
            - var 의 setter 는 materializeForSet() 함수에서 var로 선언한 변수에 대한 초기 값을 바로 할당하지 않는다. lazy 로 동작 가능.
    5. NSObject 상속 객체
        - 내부적으로 Objective-C 객체로 자동으로 변환되고, Objective-C 런타임에서 동작한다.
        - 소멸함수에 해당하는 deinit() 이 없고, 소멸함수는 NSObject.deinit() 을 호출한다.


2. 객체 정체성과 등가성
    1. 메모리 구조
        - 텍스트 영역: 프로그램 코드
        - 데이터 영역: 고정값이 정해진 전역 변수
        - 심벌 영역(BSS segement): 초기 값을 0으로 할당하는 전역 변수
        - 힙 영역(HEAP): 객체 인스턴스(동적 할당)
        - 스택 영역(STACK): 해당 힙 메모리 주소를 스택 영역에 할당한 포인터로 참조해 접근
        - 포인터 변수에 담긴 메모리 주소와 해당 주소의 객체 인스턴스가 실제 유효한지 포인터 주소만으로는 판단 불가능. => RC로 객체포인터가 유효하도록 보호
        - 클래스의 메서드는 클래스명과 메서드명이 합쳐진 형태와 비슷한 형태를 가진 셀렉터(SELECTOR)로 매핑 되며, 구현 부분은 텍스트 영역에 기계어로 저장 된다.
    2. 객체 정체성
        - 객체 인스턴스가 힙 영역에 만들어지면서, 객체는 각자 고유한 메모리 영역을 차지하게 됨.
        - 객체 각각은 고유한 정체성(메모리 주소) 를 갖음.
        - 동일한 객체의 정체성
            - a = b; 코드로 작성 된 경우, 두 객체는 동일한 객체 정체성을 갖음.
    3. 객체 등가성
        - 객체 인스턴스는 각각 고유한 메모리 영역을 차지하기 때문에, 동일한 속성(혹은 변수)에 대해서도 각자의 메모리 영역에 데이터를 보관한다.
        - 두 객체 인스턴스의 속성 및 변수가 동일한 데이터 값을 갖는 경우, 두 객체는 객체 속성에 대한 등가성을 갖는다.
        - 객체 등가성을 비교하기 위하여, isEqual 메서드를 오버라이드 해서 구현하여야 한다. => hash 값으로 비교 되기 때문에, Hashable 프로토콜을 채택 하여야함.
    4. 객체 예외성
        - Static 변수로 생성 될 경우, 객체 인스턴스는 힙영역에 할당 되는 것이 아니라, 텍스트 영역과 데이터 영역에 생성된다.
        - 동일한 값을 같는 여러개의 Static 변수들에 대해, Objective-C 에서는 문자열 인터닝을 통해 동일한 정체성을 부여 받게 된다.
        - 스위프트의 경우, 텍스트 영역에 있는 데이터로 OpaquePointer 형태 포인터로 그래도 연결 하는 방식을 사용한다.


3. 객체 사이의 관계
    1. 메타 클래스
        - 각 클래스는 인스턴스 메서드 목록과 코드를 갖고 있고, 메타 클레스는 클래스 메서드 목록과 코드를 갖고 있다.
    2. 상속
        - 객체 중심 프로그래밍 언어가 갖는 특징은 '추상화한 클래스 명세', '객체 인스턴스의 활용', '캡슐화', '상속', '다형성'.
        - 상속은 모든 클래스의 관계를 구성하는 기본적인 방식.
        - 최상위 클레스에 가장 일반화된 속성과 행동을 추상화 해 놓으면, 하위 클래스들은 상위 클래스를 상속 받아 좀 더 구체화 된다.
        - 클레스에 대한 메타 클레스를 연결하는 isa 포인터가 존재하고, 비로 밑에 상속을 받은 상위 클래스를 연결하는 super_class 포임터가 존재.
        - 상속 받은 모든 클래스의 경우 super 포인터를 따라가면 상위 클래스가 존재하고, 최상위 클래스(root class)는 super 포인터 값이 nil.
    3. 'is-a' vs 'has-a'
        - 일반적인 객체 중심 언어에서 'is-a' 관계는 객체 인스턴스와 클래스의 관계 또는 서브 클래스와 슈퍼 클래스의 상속 관계를 나타냄.
        - Objective-C에서는 객체 인스턴스와 클래스의 관계(클래스와 메타 클래스의 관계 포함)를 'is-a'로 나타내고, 서브 클래스와 슈퍼 클래스의 관계는 super로 구분해서 사용.
        - Objective-C 에서 parent - child는 상속 관계 보다 포함 관계 일 때, 사용.
        - 'has-a' 관계는 강한 참조 결합성을 갖는 구성 관계(composition)와 약한 차마조 겷바성을 갖는 집합 관계(aggregation)로 구분.
        - 구성 관계는 참조하는 객체(referrer)가 사라질 때, 하위 객체(referee)들도 같이 사라지는 방식으로, 참조하는 객체와 하위 객체가 동일한 생명주기를 갖는다.
        - 집합 관계는 참조하는 객체가 사라지더라도 하위 객체는 사라지지 않는다.

        
4. Objective-C 런타임
    - 클래스와 메타 클래스를 메모리에 로딩하는 역할은 Objective-C 런타임이 담당.
    - 런타임은 실행 중에 객체에게 보내는 메시지를 처리할 메서드를 찾거나 객체 메모리 관리, 동적 타입 변환 등을 처리하는 C 함수 라이브러리.
    1. 메시지 디스패치
        - Objective-C는 객체의 메서드를 직접 호출 하지 않고, 스몰토크 언어처럼 객체에 메시지를 보내는 방식으로 동작.
        - 컴파일 하면서 objec_msgSend() 런타임 API를 사용하는 코드로 대체.
        - 실행 중에 Objective-C 런타임은 objec_msgSend()를 실행하면서 메시지로 어떤 메서드를 실행할지 메시지 디스패치 과정을 통해서 찾아냄.
        - 컴파일러는 수신 객체의 클래스 타입과 메시지 셀렉터를 기준으로 어떤 메서드를 실행할지 선택.
        - 만약 상속 관계가 있는 경우, 다형성을 따라 상위 클래스의 메서드를 선택 하기도 함.
        - 특정 클래스의 어느 메서드를 실행 할 지 셀렉터를 고른 후, IMP('인스턴스명', @selector('메서드 명'), '파라미터'); 형태로 해당 객체의 메서드 구현부 메모리 주소를 확인해서 메서드를 호출 할 준비를 끝냄.
        - 찾은 메모리 주소는 내부 캐시에 저장하고, 이후에는 캐시에서 검색함.
        - 메서드 선택 방법을 최적화 하기 위하여, 메서드에 대한 구현부 메모리 주소를 시스템 수준의 캐시로 저장.
        - 메시지를 찾을 때마다 해시 값으로 캐시를 확인하고 데이터가 없거나 메모리 주소가 바뀌면 새로 업데이트.