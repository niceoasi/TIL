
1. Class 와 Instance
    - 객체지향: 객체 안에 속성과 메서드 형태로 함수를 구현하고 프로그램을 구성하는 객체들끼리 메시지를 주고 받아 협력 하는 형태로 동작.
    - 클래스: 문제 해결을 위해 추상화해서 만드는 코드
    - 객체: 프로그램을 실행하는 시점에 메모리에 구체화된 실체(Instance)
    1. 자연에 실존하는 객체를 그에 대응하는 형체가 없는 개념과 언어로 추상화시켜 생각 하는 방식.
    2. 객체 중심 프로그래밍
        - 개념(같은 언어를 사용하는 사람들끼리 생각하는 방식에 대한 원칙(단어의 의미, 문법)) 과 구현(실제 상황에 따라 달라지는 표현 방식)
        - 클래스 코드 --일반화, 추상화--> 객체 인스턴스
        - 클래스 코드 <--구체화, 개별화-- 객체 인스턴스
        - 클래스 단위로 역할과 책임을 나누고, 코드로 표현하기위한 설계에 필요한 다섯가지 원칙: SOLID
            - 클래스 코드를 작성할 때 명확하고 깔끔한 책임 구조와 높은응집혁, 낮은 의존성, 변화에 대한 유용성 등
    3. Objective-C 객체
        - 변수의 포인터가 가리키는 객체 인스턴스는 클래스의 코드를 공유하고(객체 인스턴스의 포인터가 클래스를 가리킴), 다른 인스턴스와는 구분되는 고유한 데이터를 포함.
        - 객체 인스턴스는 isa 포인터로 자신을 추상화한 클래스를 가리킨다.
        - 클래스로 작성한 코드는 모든 객체가 공유하고, 클래스 명세를 기준으로 만들어진 각각의 객체 인스턴스가 클래스 코드를 재사용.
    4. 스위프트 네이티브 객체
        - 스위프트 네이티브 객체는 다른 객체를 지정하지 않아도, 생성을 위해 allocating_init()과 init() 함수를 생성하고, 소멸을 위해 deallocating_deinit()과 deinit() 함수를 생성.
        - Objective-C 객체는 메모리 할당을 위한 +alloc 메서드와 초기 값을 설정하는 -init 메서드가 나눠져 있지만, 스위프트 객체는 allocating_init() 함수에서 alloc_ref() 함수를 통해 메모리를 할당하고 곧바로 init() 메서드를 호출해서 내부 변수를 초기화함.
        - deallocation_deinit() 메서드는 숨겨진 첫번째 %0 파라미터인 self 객체 레퍼런스를 class.deinit() 메서드에 넘겨서 힙에 만들어진 레퍼런스 변수를 소멸하고, dealloc_ref() 함수를 통해 자기 스스로를 메모리에서 해제
        - SIL(Swift Intermediate Language): 스위프트 컴파일러 swiftc가 스위프트 언어로 작성된 코드 파일을 읽어 스위프트 중간언어(SIL) 로 만들고 LLVM IR로 변환 후, LLVM IR 최적화기를 거쳐서 최종적으로 타깃 머신에 맞는 기계 코드(MC)가 생성된다.
        - getter / setter
            - let 으로 선언된 경우, 변경이 불가능 하기에 setter 함수는 없고, getter 함수에서 ref_element_addr() 명령으로 객체 변수의 참조 주소를 가져오고 load() 명령으로 실제 메모리에서 값을 복사.
            - swiftc는 중간언어를 세밀하게 나눠서 스위프트 런타임 API 함수를 호출하거나 더 낮은 수준의 LLVM IR로 바꾸기도 한다.
            - var 의 setter 는 materializeForSet() 함수에서 var로 선언한 변수에 대한 초기 값을 바로 할당하지 않는다. lazy 로 동작 가능.
    5. NSObject 상속 객체
        - 내부적으로 Objective-C 객체로 자동으로 변환되고, Objective-C 런타임에서 동작한다.
        - 소멸함수에 해당하는 deinit() 이 없고, 소멸함수는 NSObject.deinit() 을 호출한다.


2. 객체 정체성과 등가성
    1. 메모리 구조
        - 텍스트 영역: 프로그램 코드
        - 데이터 영역: 고정값이 정해진 전역 변수
        - 심벌 영역(BSS segement): 초기 값을 0으로 할당하는 전역 변수
        - 힙 영역(HEAP): 객체 인스턴스(동적 할당)
        - 스택 영역(STACK): 해당 힙 메모리 주소를 스택 영역에 할당한 포인터로 참조해 접근
        - 포인터 변수에 담긴 메모리 주소와 해당 주소의 객체 인스턴스가 실제 유효한지 포인터 주소만으로는 판단 불가능. => RC로 객체포인터가 유효하도록 보호
        - 클래스의 메서드는 클래스명과 메서드명이 합쳐진 형태와 비슷한 형태를 가진 셀렉터(SELECTOR)로 매핑 되며, 구현 부분은 텍스트 영역에 기계어로 저장 된다.
    2. 객체 정체성
        - 객체 인스턴스가 힙 영역에 만들어지면서, 객체는 각자 고유한 메모리 영역을 차지하게 됨.
        - 객체 각각은 고유한 정체성(메모리 주소) 를 갖음.
        - 동일한 객체의 정체성
            - a = b; 코드로 작성 된 경우, 두 객체는 동일한 객체 정체성을 갖음.
    3. 객체 등가성
        - 객체 인스턴스는 각각 고유한 메모리 영역을 차지하기 때문에, 동일한 속성(혹은 변수)에 대해서도 각자의 메모리 영역에 데이터를 보관한다.
        - 두 객체 인스턴스의 속성 및 변수가 동일한 데이터 값을 갖는 경우, 두 객체는 객체 속성에 대한 등가성을 갖는다.
        - 객체 등가성을 비교하기 위하여, isEqual 메서드를 오버라이드 해서 구현하여야 한다. => hash 값으로 비교 되기 때문에, Hashable 프로토콜을 채택 하여야함.
    4. 객체 예외성
        - Static 변수로 생성 될 경우, 객체 인스턴스는 힙영역에 할당 되는 것이 아니라, 텍스트 영역과 데이터 영역에 생성된다.
        - 동일한 값을 같는 여러개의 Static 변수들에 대해, Objective-C 에서는 문자열 인터닝을 통해 동일한 정체성을 부여 받게 된다.
        - 스위프트의 경우, 텍스트 영역에 있는 데이터로 OpaquePointer 형태 포인터로 그래도 연결 하는 방식을 사용한다.
