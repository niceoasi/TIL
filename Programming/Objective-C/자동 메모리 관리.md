1. ARC(자동 참조 계산)
    - Clnag: C언어 계열 LLVM 컴파일러
        - 최초(2010, Xcode4)에는 정적 분석기능 포함.
        - 정적 분석 기능: 소스 코드를 분석해서 실행 시점에 발생할 수 있는 이슈를 찾아내 XML 파일 형태로 저장 후, Xcode에서 결과를 코드상에 시각적으로 표시.
    - ARC: 컴파일러가 메모리 관리를 위해 코드를 자동으로 작성.
    1. 수동 참조 계산 방식과 비교
        - ARC도 MRC와 동일하게 객체마다 참조 횟수가 있고, 객체 소유권에 대한 동일한 기준으로 참조 계산을 진행.
    2. ARC 규칙
        - 컴파일러가 컴파일 하는 동안 객체 인스턴스별로 생명주기를 분선해서 자동으로 retain, release 메시지를 보내는 코드를 채워 넣기 때문에, 작성할 필요 없다.
        1. 메모리 관리 메서드를 구현하지 말것.
            - ARC 방식으로 작성하는 코드는 retain, release, retainCount, autorelease, dealloc 메서드를 구현 및 호출 하면 안된다.
            - 단, Core Foundation 스타일 객체 관리를 위한 함수들은 사용 가능.
        2. 객체 생성을 위한 메서드 이름 규칙을 따를것.
            - alloc/new/copy/mutableCopy 로 시작하는 메서드는 소유권을 갖음.
            - 객체 타입을 반활할 시, id 타입 대신, instancetype 타입을 사용 권장.
        3. C 구조체 내부에 객체 포인터를 넣지 말것.
            - C언어에서 사용하는 struct나 union 내부에 Objective-C 객체 포인터를 넣으면 ARC에서 메모리 관리를 할 수 없음.
            - C 구조체 내부에 있는 객체 포인터는 컴파일러가 관리 할 수 없어서 오류 발생.
            - __unsafe_unretained: ARC가 관리하지 않는 다는 것을 강제로 명시. (dangling pointer 접근 위험)
        4. id와 void* 타입을 명시적으로 타입 변환 할것.
            - 객체 생명주기를 관리하기 위해서 타입 변환을 할 시, 명시적으로 타입 변환 연산자를 사용.
        5. NSAutoreleasePool 대신 @autoreleasepool 블록 코드를 사용 할것.
        6. 메모리 지역(zone)을 사용 하지 말것.
    3. 소유권 수식어
        - __strong: 기본 수식어, 강한 참조, 소유권을 갖고 있음.
        - __weak: 약한 참조, 참조하는 객체가 살아 있음을 보장하지 않음, 참조하는 곳이 없으면 객체는 사라지고 nil 포인터가 됨.
        - __unsafe_unretained: Cocoa 프레임웍 내부에서 만든 객체를 넘겨받을 때는 __autoreleasing 지시어를 사용해서 자동 해제될 대상이라고 명시.
        - __autoreleasing
            - __weak 수식어와 마찬가지로 소유권을 갖지 않는 참조 관계, 하지만 객체가 사라지면 nil로 바꿔주지 않고 메모리 관리를 하지 않아 안전하지 않다.
            - 객체 포인터를 일시적으로 참조만 하는 경우에만 예외적으로 사용하기를 권장.
            - 안전한지는 모르지만 참조하는 객체가 확실히 존재하는 경우나 참조할 객체가 약한 참조가 될 수 없는 경우 __unsafe_unretained 수식어 사용.
    4. 타입 연결
        - Objective-C로 만들어진 코코아 프레임웍 내부에 C언어로 만들어진 코어 파운데이션 프레임웍이 존재.
        - Objective-C로 만들어진 객체도 내부에 구현한 코드는 코어 파운데이션 C 구조체를 사용.
        - 무비용 연결: 코어 파운데이션 구조체와 Objective-C 객체 사이 연결이 가능하고 추가적인 비용이 발생하지 않음.
        - 코어 그래픽스 처럼 C언어 수준의 API를 사용하는 경우에는 C 구조체 포인터를 사용 할 수 밖에 없는데, 이 경우는 메모리 관리가 자동적으로 이뤄지지 않는다.
        1. __bridge 방식
            - 두가지 경우 다 사용 가능.
            - 객체의 소유권을 넘기지 않고, 타입 연결만 하는 경우.
            - 허상 포인터가 생길 수 있기 때문에 매우 위험, 포인터에 대한 예외 처리를 꼭 해주고, 객체 소유권 관리를 신경 써 줘야 한다.
        2. __bridge_retained 또는 CFBridgingRetain 방식
            - Objective-C 객체를 코어 파운데이션 포인터로 연결하면서 소유권도 주는 경우에 사용.
            - 소유권을 주기 때문에 RC가 1 증가 하기 때문에, 참조가 완료 되면 CFRelease()와 같은 함수를 호출 하여 소유권 반환.
            - 타입 변환 후, 해당 객체를 retain.
        3. __bridge_transfer 또는 CFBridgingRelease 방식
            - __bridge_retained 방식과 반대로 코어 파운데이션 참조 포인터를 Objective-C 객체로 연결하면서 소유권도 넘기는 경우 사용.
        4. 무비용 연결 타입
