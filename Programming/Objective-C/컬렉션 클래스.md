1. 순서가 있는 배열 컬렉션
    - 불변 배열과 가변 배열
        - 불변 배열 객체로 초기화하면서 참조할 객체를 지정한 이후에는 객체를 추가하거나 삭제하는 등의 변경은 불가능 하지만, 참조하는 객체가 가변 객체라면 해당 객체는 수정 가능.
        - 참조 객체는 해당 객체를 복사하는 것이 아닌 강한 참조로 소유권을 갖는다.
    - 탐색, 정렬, 필터링
    - 널가능성과 제네릭
        - Nullability
            - _Nonnull: 절대 nil이 될 수 없음.
            - _Nullable: nil이 될 수 있음. - 스위프트의 Optional
            - _Null_resettable: nil로 설정 할 수 있지만, 명시적으로 nil 값이 될 수 없음. - 스위프트의 implicitly unwrapped optionals
            - _Null_unspecified: nil 여부를 판단하지 않음.

    1. 배열 성능 특성
        - NSArray와 CFArray 객체는 무비용 연결이 가능한 거의 동일한 객체 - NSArray로 생성해도 내부적으로 CFArray를 생성.
        - Fast Enumeration > NSArray > CFArray

    2. 포인터 배열
        - NSMutableArray와 비슷하게 참조 객체를 추가 가능 및 nil 값 포함 가능.
        - 메모리 관리 선택 사항으로 객체를 약한 참조로 접근 할 수 있고, 강한 참조로도 접근 가능.
        - 포인터 배열을 생성하는 두 가지 방법
            - 정해진 옵션 지정
            - 함수 포인터 지정 방식
                - NSPointerFunctions를 활용해서 포인터에 있는 데이터를 다룰 함수 포인터들을 지정하는 방식을 사용.
                    - 등가성을 판단하기 위한 Hash(), IsEqual().
                    - 설명을 위한 Description().
                    - 메모리 할당을 위한 Acquire()와 해제를 위한 Relinquish().
        - 포인터 배열에 넣을 포인터 변수가 scope에 포함된 지역 변수처럼 스택에 생기는 포인터인 경우, 필수적으로 메모리 복사를 해야한다. 메모리를 복사하지 않는 경우, 포인터 배열로 참조하더라고 해당 scope를 벗어나게 되면 참조할 수가 없음.

    3. 중첩된 배열 접근하기
        - NSIndexPath 객체 사용.

    4. 스위프트 배열
        - 구현 방식에 따라 Array<Element>, ContigousArray<Element>, ArraySlice<Element> 세가지 형태로 나뉨.
            - Array<Element>: NSArray와 유사.
            - ContigousArray<Element>: C 배열처럼 배열 요소가 연속해 있다고 가정, 동작 방식이 달라 NSArray와 연결 불가능. Array 보다 성능이 좀 낫다.
            - ArraySlice<Element>: 어떤 배열 타입이든지 잘라서 일부 요소만 표현할 수 있도록 도와줌, 내부에서 ContigousArray 방식을 사용하기 때문에 NSArray와 연결 불가능.
        - value sematics을 유지하면서 성능을 유지하기 위해서copy-on-write 방식을 구현.
        - 성능 저하를 최소화하면서 Objective-C 배열 객체와 연결할 수 있도록 만들어졌음.
        - Array<Element> 배열은 요소 항목이 클래서이거나 @objc 프로토콜을 지원하는 타입인 경우, 배열은 내부 NSArray에 저장되어, 다른 NSArray로 연결하는 경우 시간 복잡도는 O(1) 이다. 하지만, ContiguosArray나 ArraySlice의 경우 각 항목별로 복사하고 연결해야 하기 때문에 복잡도는 O(n)이 된다.
