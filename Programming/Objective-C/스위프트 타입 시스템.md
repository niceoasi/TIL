1. 타입 시스템
    - 자바 스크립트나 파이썬처럼 자유로운 덕 타입 시스템이 아니라 명시적인 타입 시스템.
    1. 스위프트 타입
        - 이름 있는 타입: 클래스, 구조체, 열거, 프로토콜.
        - 이름 없이 합쳐진 타입: 튜플, 클로저/함수 타입으로 이름이 따로 정해지지 않고, 다른 타입들을 합쳐서 사용.

    2. 타입 검사
        - 안전한 타입 언어: 값에 대한 타입을 명확하게 구분해서 사용할 수 있는 언어.
        - 타입 추론
            - ML 언어 계열에서 많이 사용하는 HM 타입 추론 알고리즘을 구현하는 타입 제약을 이용.
            - 컴파일러는 문맥에 따라서 제약 사항을 수식으로 만들고 HM 타입 추론 알고리즘으로 특정 변수나 표현식 타입에 적합한지 계산.
            - 타입 제약은 타입 비교를 통한 등가성을 판단하고, 서브 타입에 대한 조건을 비교.
            1. 제약 만들기: 컴파일 요소로 분석해야 하는 표현식과 문맥 정보에서 유추해야 하는 숨겨진 표현식을 분석해서 각 요소들 타입 관계를 제약 사항 집합으로 만듦.
            2. 제약 계산하기: 제약 사항들을 계산해서 여러 가지 가능성 중에서 가장 적합한 타입을 찾기 위한 준비 단계.
            3. 제약 판단하기: 앞 단계에서 만든 제약 사항, 표현식과 확정적인 타입 정보까지 포함해서 종합적으로 정확한 타입 정보를 포함하는 표현식을 재생산.
        - 타입 변환
            - 데이터 타입의 메모리 구조가 동일하고 다루는 소재가 다른 타입끼리만 타입을 변환 가능.
            - 구조체 타입이나 클래스 타입에서 상속받은 객체들끼리는 구조 동일성이 유지 되기 때문에 타입 변환이 가능.

    3. 의미 있는 값 vs. 의미 있는 레퍼런스
        - 의미 있는 값: 값 자체가 중요.
        - 의미 있는 레퍼런스: 레퍼런스 방식으로 참조하는 대상이 중요.
        - 값 방식은 참조 계산을 하지 않기 때문에 그만큼 병렬 처리나 성능 최적화 측면에서 유리.
        - 타이별 성능 비교
            - 스택 메모리의 경우, 사용할 때 스택 포인터를 증가시키고 사용하지 않을 때 스택 포인터를 감소시키면 됨.
            - 힙 메모리를 사용하는 경우, 비어 있는 힙 공간을 찾고 빈 메모리 공간을 처리하기 위한 별도의 데이터 구조가 필요.
            - 여러 스레드에 대한 안정성 확보를 위한 동작이 필요할 경우힙이 상대적으로 느림.


2. 열거 타입
    - 스위프트 열거 타입은 타입 지정 가능하고 값이 있거나 없을 수 있다.
    - 확장과 함수를 만들 수 있음.
    1. 열거 타입과 프로토콜
        - 열거 타입에 정의한 값은 기본적으로 Hashable 프로토콜을 지원해야 함.
        - Hashable 프로토콜은 Equatable 프로토콜을 상속받아 만들어져서, 추가적으로 Equatable 프로토콜에 있는 == 비교 함수까지 구현해야 함.
        - 프로토콜 타입과 증거 테이블
            - 클래스 타입에 대한 상속과 다형성은 가상 함수들을 런타임에 찾는 다이내막 디스패치 방식을 사용한다.
            - 다른 타입들은 프로토콜 중심 프로그래밍 방식에 맞춰서 프로토콜 증거 테이블을 사용해서 다형성을 구현.
        - Equatable 프로토콜
            - == 비교 함수는 좌우에서 각각 enum.PenModels 파라미터를 받아서, 좌측 값에 대한 case 비교문 Int 값과 우측 값에 대한 case 비교문 Int 값을 구하고, Int 타입의 == 비교함수를 통해서 최종적으로 같은 값인지 판단.

    2. 연관 값을 가지는 열거 타입
        - 다른 언어에 있는 variants나 unions 형태로 여러 타입에 대한 값이 있을 수 있음.

    3. 가공 없는 값을 가지는 열거 타입
        - 가공 없는 값을 가지는 열거 타입의 경우 생성자가 만들어지고, 열거 타입 값들과 비교.
        - 열거 타입과 매칭이 되면 값이 들어가고, 매칭이 되지 않으면 null을 할당.


3. 구조체 타입 
    1. 구조체 타입
        - 클래스와 비슷하게 생명주기를 가지는 타입.
        - init() 함수는 구조체를 위한 메모리 박스를 할당한 다음, 내부 변수 타입의 초기화 함수를 사용해서 초기 값을 지정.
        - 가변 변수가 포함된 경우
            - 처음에 값이 없다가 나중에 내부 함수에서 설정하거나 접근 요청할 때 계산하는 프로퍼티에서, 옵셔널 처리와 안전한 예외 처리를 위해 사용하는 내부 전용 함수.

    2. 구조체 타입 기반의 스위프트 타입
        - 스위프트 표준 라이브러리는 구조체 타입을 기반으로 작성된 타입이 대부분.


4. 문자열 타입
    - 유니코드를 다루기 적합하도록 구현됨.
    1. 문자열 코어
        - ASCII 형태부터 UTF16 형태까지 모두 저장할 수 있는 최적화된 내부 문자열 타입.

    2. 문자열과 메모리
        - 문자열 값을 바꾸기전까지는 동일한 메모리를 그대로 갖고 있는 쓰기 직전 복사 방식으로 동작.

    3. 문자열 뷰
        - 문자열 타입은 문자를 넣어놓은 배열도, 문자들을 모아놓은 컬렉션 타입도 아니다.
        - 문자열 타입을 마치 컬렉션 타입처럼 다룰 수 있도록 도와주는 뷰 속성들이 있을 뿐이다.
        - 문자열 뷰
            - 문자열 뷰에 접근하면 내부적으로는 characterView라는 새로운 구조체를 만들고 문자열 코어를 복사해서 문자 단위로 접근할 수 있도록 확장한 함수들을 제공한다.
        - 유니코드 스칼라 뷰
            - 내부적으로 UnicodeScalaView 구조체 내부에 새로운 문자열 코어를 복사해서 접근가능하도록 도와줌.
        - UTF8View와 UTF16View
            - 유니코드 표준에서 8비트 코드 유닛을 지원하는 UTF8 인코딩과 16비트 코드 유닛을 지원하는 UTF16 문자에 대한 컬렉션 뷰를 제공한다.
