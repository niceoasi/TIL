1. 코코아 프레임워크 핵심 패턴
    1. 두단계 초기화 패턴
        - 객체 인스턴스에 대한 메모리 관리를 위한 패턴
        - 초기화 과정
            - 클래스에 alloc 메시지를 보내, 힙 공간에 객체 인스턴스 메모리 공간을 할당.
            - 객체 인스턴스에 init 메시지를 보내 객체 인스턴스 속성이나 내부에 필요한 객체나 값을 초기화.
        - 지정 초기화 메서드
            - 상속받은 서브 클래스에서 지정 초기화 메서드를 구현할 때는 반드시 부모의 지정 초기화 메서드를 호출해야 한다.
            - 상속받은 서브 클래스에서 부모에 없는 새로운 보조 초기화 메서드는 자기의 지정 초기화 메서드를 호출해야 한다.
            - 슈퍼 클래스의 지정 초기화 메서드에서 반환되는 객체는 self에 할당한다.
            - 슈퍼 클래스의 지정 초기화 메서드에서 nil을 반환하면, 인스턴스 내부 변수를 사용하지 않고 nil을 그대로 반환한다.
    
    2. MVC 패턴
        - 객체의 역할을 구분하는 패턴
        - 모델 객체
            - 화면을 구성하거나 내부 처리를 위한 데이터를 추상화해서 타입을 지정한 자료 구조로 표현하고, 데이터를 처리하는 로직을 정의.
            - 화면을 구성하는 뷰 객체와 직접적으로 연결하지 않음.
        - 뷰 객체
            - 앱 화면 자체에 그려서 표시하는 역할을 하고, 사용자 선택에 따라 입력을 받거나 피드백을 줌.
        - 컨트롤러 객체
            - 뷰 객체와 모델 객체 사이에서 사용자 입력과 데이터 변화에 대한 연결을 해주는 중재자 역할.
    
    3. 메시지 셀렉터 패턴
        - 다른 객체가 코오라 객체에게 메시지를 보내면 코코아 런타임은 해당 객체 메서드 중에서 메시지를 처리할 메서드를 찾아서 메서드의 함수 포인터를 호출.
        - 런타임이 메시지에 해당하는 객체 메서드에서 찾는 과정을 '다이나믹 디스패치'라고 부름.
        - 객체가 처리할 메시지를 지연시키는 패턴
        - 셀렉터와 구현 포인터
            - 셀렉터는 메시지를 받을 객체의 메서드 중에서 적합한 메서드를 고르는 역할.


2. 객체 사이 결합성을 줄여주는 패턴
    1. 싱글턴 패턴
        - 인스턴스가 딱 하나만 있는 객체.
        - 앱 내부에서 공통적으로 사용하는 객체 인스턴스가 딱 하나만 있기 때문에 다른 객체들이 서로 공유 해서 사용.
        - UIApplication 공유 인스턴스
            - main.m 파일을 main() 함수 내부에 있는 UIApplicationMain() 함수를 통해 UIApplication 싱글턴 객체를 생성.
            - UIApplication 객체는 앱의 이벤트 전달과 액션 처리를 위한 무한 루프를 갖고 있음.
            - 앱 수준에서 중요한 이벤트와 생명주기 관리는 UIApplcationDelegate 객체에서 처리.
            - UIWindow 객체들을 관리.
        - 싱글턴 구현 방법
            - 앱 시작 시점에 미리 만들어 놓고 바로 공유 인스턴스를 참조하는 방법.
            - 공유 인스턴스에 처음 접근 하는 늦은 시점에 객체 인스턴스를 생성하는 방법.
            - 앱 생명주기에 맞춰서 한 번만 실행되는 부분에서 객체 인스턴스를 미리 만들어두는 방법.
        - NSFileManger 공유 인스턴스
            - 멀티 쓰레드 환경에서 안전하지 않기 때문에, 쓰레드 별로 인스턴스를 생성해서 쓰도록 권장.
    
    2. 옵저버 패턴
        - 객체 상태 또는 내부 값이 빠뀌면 그 값을 참조하는 다수의 의존적인 객체에 알려주는 패턴.
        - 특정 객체의 상태 변화에 대해 미리 구독할 객체를 등록 해놓고, 상태 변화가 발생하면 통보하는 방식으로 동작.
        - notification
            - NSNotificationCenter 는 보내려는 notification을 확인하고 notification을 전송할 조건을 확인해서 조건에 부합하는 옵저버 객체에 메시지를 보냄.
        - NSNotificationCenter 클래스
    
    3. 응답 체인 패턴
        - GoF 디자인 패턴의 'Chain of Responsibility' 패턴.
        - 특정한 메시지에 응답할 객체를 바인드하거나 지정해서 결합성을 높이지 않고, 응답할 가능성이 있는 객체들을 체인 형태로 차례대로 확인하고 더 이상 응답할 객체가 없을 때까지 반복해서 확인하는 방식.
        - 응답 객체(Responder Object)
            - 이벤트를 받아서 응닿바는 모든 객체의 최상위 클래스는 NSResponder.(뷰, 윈도우 포함)
        - 처음 응답 객체
            - 응답 체인의 처음 항목을 지칭하는 프락시 객체.
            - 응답 체인의 객체들을 모두 확인했는데 처리한 객체가 없다면 해당 이벤트는 무시됨.
        - 응답 체인 탐색
            - 뷰 계층을 따라서 포커스된 화면 객체들 중에서 특정 뷰에서부터 윈도까지 이어진다.
    
    4. 호출 패턴
        - 셀렉터와 타깃 객체를 지정하고 인자 값을 넘겨서 타깃의 셀렉터를 호출하는 방식으로 구현.
        - NSInovocation 클래스
            - Objective-C 메시지를 객체로 추상화하기 때문에 메시지와 함께 전달해야 하는 속성들을 객체로 표현할 수 있음.
            - 주의 사항
                - 항상 +invocationWithMethodSignature 지정 생성자를 이용해서 생성하고 초기화를 해야함.
                - -setArgument:atIndex: 메서드로 인자 값을 설정할 때 두 번째부터 인자 값을 지정해야 한다.
                    - 0번째와 첫 번째는 런타임에서 객체에 메시지를 보낼 때 self와 _cmd 값을 보관하는 용도로 쓰임.
                    - 넘기는 인자 값에 객체 참조가 있을 경우 효율성을 위해서 소유하지 않는다.


3. 객체 내부의 복잡성을 감춰주는 패턴
    - 객체 설계 범위는 객체마다 갖는 고유한 역할과 책을을 기준으로 정함.
    1. 팩토리 추상화 패턴
        - 세부 클래스를 지정하지 않고 관련된 클래스 패밀리를 생성할 수 있는 인터페이스를 제공.
        - NSString ,NSData, NSArray, NSDictionary, NSSet

    2. 파사드 패턴
        - 클래스 클러스터와 비슷함.
        - 내부 객체들의 복잡한 관계를 감추고 하나의 클래스가 인터페이스를 모두 담당하는 패턴.
        - NSImage와 UIImage

    3. 번들 패턴
        - 실행 파일과 프로그램에서 사용하는 인터페이스, 문자열, 이미지, 음악 같은 리소스를 디렉터리에 구조적으로 묶어 놓은 것을 말함.
        - 프레임웍들은 '패키지 번들 구조'
        - Info.plist
            - 번들 구조에서 앱에 대한 기본적인 정보들을 저장.
            - 키 값은 코어파운데이션 CFBundle에 선언되어 있어서 상수앞에 CF 접두어가 있음.
        - 리소스 지역화
            - 지역화하지 않는 글로벌 리소스는 Resources 디렉터리에 포함.
            - 사용자 지역 설정에 맞춰서 지역별 지역화 리소스를 찾는다.
            - 사용자 언어 설정에 맞춰서 언어별 지역화 리소스를 찾는다.
            - Info.plist에 기본 언어로 지정한 개발 언어 리소스를 찾는다.
        - iOS 앱 번들
            - 실행 파일과 리소스 전체가 하나의 디렉토리로 구성.

    4. 프락시 패턴
        - 프락시 객체는 다른 객체를 감싸거나 대신해서 접근하는 기능을 제공.
        - 프락시 객체는 원하는 메시지를 다른 객체로 전달하는 역할.
        - 메시지 포워딩
            - 동적 메서드 추가하기
                - 클래스에 +resloveInstanceMethod: 메서드가 구현되어 있는지 보고 호출.
                - 메서드에서 미리 준비한 메서드가 있으면 class_addMethod() 같은 런타임 API로 메서드를 추가하고 YES를 리턴하면 해당 메서드를 다시 호출.
            - 곧바로 포워딩하기
                - 해당 객체에는 셀렉터가 구현되지 않았기 때문에 다른 객체가 처리할 수 있는지 확인해서 다른 객체로 메시지를 포워딩.
            - 완전 포워딩하기
                - 호출 패턴.
