1. NSCopying 계열 프로토콜
    - 객체를 복사하기 위한 방법으로 <NSCopying> 또는 <NSMutableCopying> 프로토콜을 지정해서 필요한 메서드를 구현하는 방법을 권장
    
    1. 복사만 가능한 객체
        - <NSCopying> 프로토콜: -(id)copyWithZone:(NSZone*)zone;
            - 더 이상 메모리 영역을 zone으로 나눠서 사용하지 않기 때문에 인자 값을 nil로 넘겨도 됨.
        - 객체를 복사하기 위해서는 객체 등가성을 만족 해야 됨.
            - 내부 데이터를 한꺼번에 인자 값으로 전달할 수 있는 초기화 메서드가 있으면 복사하기 쉽고, 없는 경우는 각 속성에 대한 접근자 메서드를 이용해 개별적으로 내부 데이터를 채워 넣어야 한다.

    2. 복사와 수정이 가능한 객체
        - <NSMutableCopying> 프로토콜: -(id)mutableCopyWithZone:(NSZone*)zone;


2. 얕은 복사 vs 깊은 복사
    - 내부에 다른 객체를 포함하는 경우 객체를 복사할 때 주의 해야함.
    - 객체가 객체를 포함하는 경우, 참조하는 대상 객체의 메모리 주소를 포인터 변수로 접근.

    1. 얕은 복사
        - 파운데이션 프레임웍에 있는 모든 클래스는 '얕은 복사' 형태로 구현되어 있음.
        - 이때, 내부 객체를 복사하는 경우, 참조 포인터만 복사.
        - 복사된 객체 내부 값을 변경 할 경우, 기존 객체의 내부 값도 변경됨.

    2. 깊은 복사
        - <NSDeepCopying> 프로토콜을 지정한 객체의 특정 메서드를 통해 깊은 복사를 할 수 있음.
        - 이때, 복사하는 객체와 동일한 객체가 생성 됨.


3. 아카이브
    - 깊은 복사를 구현하기 위한 두가지 방식
        - 코어 데이터: 객체 그래프를 저장하기 위한 프레임웍
        - <NSCoding> 프로토콜과 이름 있는 아카이브 클래스를 활용해서 객체를 인코딩
    
    1. 객체 직렬화와 아카이브의 차이
        - 객체 직렬화와 아카이브 모두 객체 그래프를 따라 객체의 데이터 내용을 저장하는 방식.
        - 객체 직렬화
            - 주로 문자열, 배열이나 사전 컬렉션에 담겨 있는 계층 구조와 참조하는 객체 데이터만 직접적으로 저장. 
            - 여러 곳에서 하나의 객체를 다중 참조하고 있으면, 참조마다 동일한 내용의 객체를 여러 개 저장.
            - deserialize 하게 되면 각기 다른 객체가 만들어짐.
            - 데이터 값만 저장 하기 때문에, 다시 객체화할 때 가변 객체인지 불변 객체인지 판단 할 수 없음.

    2. <NSCoding> 프로토콜
        - 프로퍼티 목록 구조는 단순하고 작은 규모의 객체끼리의 객체 그래프를 저장하는 데 적합.
        - plist는 가변 객체나 다중 참조 관계도 원래대로 복원하지 못함.
        - 제약 사항들을 지원해야 하는 경우는, plist 대신 <NSCoding> 프로토콜을 사용해야 한다.
        - <NSCoding>
            - 객체 인스턴스를 인코딩하거나 다시 객체로 디코딩하기 위한 메서드 두 개만 있는 프로토콜.
            - -(void)encodeWithcoder:(NSCoder *)encoder;
            - -(id)initWithCoder:(NSCoder *)decoder;
        - 객체 그래프와 아카이브
            - 뿌리 객체
                - 객체 그래프에 대한 탐색을 위한 시작점.
                - 아카이브를 시작하는 시점.
            - 조건부 객체
                - 객체 그래프에서 반드시 아카이브하지 않아도 되는 참조 객체.
                - 아카이빙 동안 '무조건 객체'가 전혀 없이 '조건부 객체'만 잌노딩 할 경우, 다시 디코딩해서 복원할 때 해당 객체는 참조할 수 없고 nil을 반환.
                - '무조건 객체'가 인코딩되어 있을 경우, 그 객체에 대한 참조 포인터 반환.
                - '조건부 객체'는 약한 참조 형태로 인코딩.

    3. 이름 있는 아카이브
        - 인코딩 시, NSKeyedArchiver Class 사용.
        - 변수에 대한 키 값을 이름으로 지정해서 인코딩 가능.
        - 디코딩 시, NSKeyedUnarchiver Class 사용.
        - 고유한 키 값을 지정하기 위해 키 값 규칙을 정해야 한다.
        - NS, UI, $ 접두어 사용은 지양. (이미 사용)
        - 아카이브 델리게이트
            - 각 객체를 인코딩/디코딩 시점에 알림을 받을 수 있음.

    4. 아카이브 만들기
        - +archivedDataWithRootObject:toFile: 클래스 메서드 혹은 +archivedDataWithRootObject: 클래스 메서드 사용하여 뿌리 객체부터 아카이브를 만듦.
        - 뿌리 객체로 접근 하지 않고, 직접 원하는 객체를 아카이브하려면 클래스 메서드 대신 -initForWritingWithMutableData: 메서드를 활용해서 NSKeyedArchiver 객체 인스턴스를 먼저 생성하고 초기화하고, 개별적으로 -encodeObject:forkey: 메서드로 직접 인코딩을 하고, 마지막에 -finishEncoding 메서드로 인코딩 작업이 끝났다고 알려줘야 함.

    5. 아카이브 해제하기
        - 뿌리 객체부터 해제 하려면, +unarchiveObjectWithFile: 또는 unarchiveObjectWithData: 클래스 메서드 사용.
        - 직접 처리하려면 아카이브 해제용 객체 인스턴스를 먼저 생성, -initForReadingWithData: 초기화 메서드를 사용해서 인스턴스를 초기화 해야하고, 그 이후에 -decodeObjectForKey: 메서드로 직접 디코딩을 하고, 마지막에 -finishDecoding 메서드로 작업이 끝났다는 것을 알려줘야 함.

    6. 객체 인코딩과 디코딩
        - 객체 타입뿐만 아니라 저장해야 하는 데이터 타입마다 인코딩, 디코딩하는 개별 메서드를 제공.
        - NSCoder 클래스에 선언 되어 있음. 

    7. <NSSercureCoding> 프로토콜
        - 기존 <NSCoding> 프로토콜에 보안성을 강화한 확장판.
        - +supportsSecureCoding 클래스 메서드로 안전한 인코딩 방식 지원여부를 판단.
        - -decodeObjectForKey: 메서드 대신 -decodeObjectOfClass:forKey: 메서드를 사용해서 아카이브한 파일 내부 클래스를 대체하는 공격 방식에 대비  가능.
        - 아카이브한 바이너리 데이터를 네트워크상으로 주고 받는 경우 해킹 위험이 있어 보안성을 강화함.
        - XPC 방식으로 객체를 아카이브해서 주고 받을 경우, <NSSercureCoding> 프로토콜을 반드시 구현하도록 강제.
