1. 함수형 프로그래밍, 그 전에 - 실용 프로그램에서 활용하는 강점 알기
    - 함수형 프로그래밍을 통해 얻을 수 있는 개선
        - 코드양이 적어진다.
        - 최적화하기 쉽다.
        - 병행/병렬화하기 쉽다.
        - 버그가 발생하기 어렵다.
        - 문서가 적어진다.


2. 함수란 무엇인가? - 명령형 언어의 함수와 무엇이 다른가?
    - 함수형 프로그래밍에서 함수
        - '주어진 입력 값만으로 단지 하나의 출력되는 값을 결정하는 규칙' 이라는 수학적 의미의 함수.
    - 부작용
        - '상태'를 참조하거나 '상태'에 변화를 줌으로써 다음 번 이후의 결과에까지 영향을 미치는 효과.
        - 부작용을 지닌 절차는 '함수' 가 아님.


3. 함수형 프로그래밍이란 무엇인가? - '프로그램이란 함수다'라는 관점
    - 값을 가지고 함수를 적용해 계산을 진행하는 프로그래밍 스타일
    - 프로그래밍의 패러다임
        - 명령형 프로그래밍의 패러다임
        - 객체지향 프로그래밍의 패러다임
        - 함수형 프로그래밍의 패러다임 - 프로그램은 '함수'다
    - 함수가 갖는 모듈화 - '프로그램을 구성하는 부품'의 독립성
        - 함수에 입력 가능한 값 전체로 이루어진 집합을 정의역, 출력 가능한 값 전체로 이루어진 집합을 치역이라고 한다.

    
4. 함수형 언어란? - 함수가 1급 대상이다? 대입이 없다?
    - 함수형 언어이기 위한 조건
        - 리터럴이 있다.
        - 실행시간에 생성할 수 있다.
        - 변수에 넣어서 취급할 수 있다.
        - 절차나 함수에 인수로서 제공할 수 있다.
        - 절차나 함수의 결과로서 반환할 수 있다.
    - 함수형 언어와 명령형 언어
        - 값을 어디에 보관할 것인가(대입)
        - 어디로부터 값을 가져올 것인가(참조)
        - 다음에 어떤 절차로 진행할 것인가(절차의 호출)
        - 대입이 없기에 얻을 수 있는 것
            - 값이 들어 있지 않은 경우가 없다(= 값이 항상 들어 있다).
            - 값이 변해 버리는 일이 없다(값이 변하지 않는다).


5. 함수형 언어의 특징적인 기능 - 타입의 유무, 정적/동적, 강약
    - typed와 untyped
    - 정적타입과 동적 타입
    - 순수 함수: 동일한 식은 언제 평가해도 같은 결과가 되는 참조 투명성이라는 성질을 갖고 있다.
    - 타입 검사
    - 강한 타입과 약한 타입: 안정성이 보장되는 강한 타입과 안정성이 보장되지 않는 약한 타입.
    - 타입의 추론: 명시적으로 부여되는 타입의 정보로부터 암시적인 부분의 타입을 추론하는 기능.
    - 의존 타입: 다른 타입에 의존한 타입이나 값에 의존한 타입을 만들 수 있는 기능.
    - 평가 전략: '어떠한 순서로 식을 평가할까' 라는 규칙.
        - 적극 평가: 인수가 전달되기 전에 평가
        - 지연 평가: 평가가 필요할 때 평가


6. 왜 지금 함수형 언어인가? - 추상화, 최적화, 병행/병렬화
    - 함수형 언어의 추상화 - 수학적인 추상화란?
        - 모듈의 재사용성을 강화하고, 구현과 인터페이스를 분리해 놓음.
        - 장점
            - 많은 문제에 대해 범용적으로 적용 가능.
            - 추상화 후의 세계에서 실시할 수 있는 조작이 많음.
    - 함수형 언어의 최적화
        - '프로그램의 정확성'이 사람의 눈에도 명확.
    - 함수형 언어와 병행/병렬 프로그래밍
        - 병렬: 물리적으로 여러 작업을 동시에 수행 가능
        - 병행: 논리적으로 여러 작업을 동시에 실행 할 수 있거나 실행 상태를 여러개 유지.
        - 목적으로부터 고려하는 병행/병렬 프로그래밍
            - 병행의 목적: 여러 태스크를 동시에 수행.
            - 병렬의 목적: 태스크의 고속화.
        - 병행 프로그래밍의 어려움 - 결합 상태, 데드락
            - 경쟁 상태: 여러 스레드가 동일한 리소스에 거의 동시에 액세스할 때 리소스가 예기치 않은 상태.
            - mutex 잠금 등을 이용하여 리소스에 접근할 때 크리티컬 섹션 내로 국한 하는 등 경쟁 상태를 일으키지 않도록 배타적 제어 필요.
            - 대표적인 트러블
                - 잠금해야 할 리소스인 것을 사양/설계/기존 코드 등으로부터 파악하지 못하고 잠금해야 하는 것을 잊음.
                - 잠금한 리소스를 사용한 후, 잠금을 푸는 것을 잊음.
                - 잠금할 필요가 없거나 아니면 필요가 있었지만 할 필요가 없어진 리소스에 대해 여전히 잠금을 하고 있어 성능이 올라가지 않음.
                - 잠금을 취할 범위가 쓸데없이 커서 성능이 올라가지 않음.
                - 스레드 두 개가 서로 잠금 상태인 리소스를 서로 취하는 바람에 데드락에 걸림.
            - 데드락
                - 잠금해야 할 두 개 이상의 리소스가 존재.
                - 이미 한 개 이상의 리소스를 잠금한 채로, 별도의 리소스의 잠금을 요구하며 기다리는 일이 있음.
                - 이미 잠금되어 있는 리소스를 다시 취할 수 없음.
                - 리소스의 잠금을 취하는 순서가 정해져 있음.
        - 병렬 프로그래밍의 기여 - 참조 투명성의 보증
        
